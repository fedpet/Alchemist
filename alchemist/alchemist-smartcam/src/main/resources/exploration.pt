module exploration
import utils
import java.lang.Math.toRadians
import java.lang.Math.abs
import java.lang.Math.PI


def getEnvironmentBoundaryForce(envPoint) {
    let myPos = self.getCoordinates()
    let versor = unitVector(myPos - envPoint)
    12000 / distanceBetweenPos(myPos, envPoint) ^ 2 * versor
}

def getEnvironmentBoundariesForce() {
    let halfEnvSize = getEnvironmentSize() / 2
    let myCoords = self.getCoordinates()
    let myX = myCoords.get(0)
    let myY = myCoords.get(1)
    let top = getEnvironmentBoundaryForce([myX, halfEnvSize])
    let right = getEnvironmentBoundaryForce([halfEnvSize, myY])
    let bottom = getEnvironmentBoundaryForce([myX, -halfEnvSize])
    let left = getEnvironmentBoundaryForce([-halfEnvSize, myY])
    top + right + bottom + left
}

def randomAngle() {
    2 * PI * self.nextRandomDouble()
}

def chooseDirection() {
    let HYSTERESIS = 0
    rep(info <- [self.getCoordinates(), randomAngle(), HYSTERESIS]) {
        let lastPos = info.get(0)
        let myDirectionAngle = info.get(1)
        let hyst = info.get(2)

        let myPos = self.getCoordinates()
        let realDirectionOfMovement = lastPos - myPos
        let realDirectionAngle = directionToAngle(realDirectionOfMovement)
        myDirectionAngle = if((distanceBetweenPos(myPos, lastPos) < getMaxMovementSpeed() / 2
            && abs(realDirectionAngle - myDirectionAngle) > toRadians(90))
            || distanceBetweenPos(myPos, lastPos) < getMaxMovementSpeed() / 4) {
            if(hyst <= 0) {
                hyst = HYSTERESIS
                randomAngle()
            } else {
                hyst = hyst - 1
                myDirectionAngle
            }
        } else {
            myDirectionAngle
        }
        [myPos, myDirectionAngle, hyst]
    } yield {
        angleToVersor(info.get(1))
    }
}

public def fieldExploration() {
    let cameraVersorsField = nbrVersor()
    //env.putField("LOG_vector", cameraVersorsField)

    let distanceFromCamerasField = self.nbrRange()
    env.putField("LOG_distanceFromCamerasField", distanceFromCamerasField)

    let cameraForces = 10000 / distanceFromCamerasField ^ 2 * cameraVersorsField
    env.putField("LOG_cameraForces", cameraForces)

    let envBoundariesForce = getEnvironmentBoundariesForce()
    env.put("LOG_envBoundariesForce", envBoundariesForce)

    env.put("LOG_cameraSumForces", sumHood(cameraForces))
    let sumOfForces = sumHood(cameraForces) + envBoundariesForce
    env.put("LOG_sumOfForces", sumOfForces)

    let myForceOfWill = 10
    let myDirection = chooseDirection()
    let myForce = myDirection * myForceOfWill
    env.put("LOG_myDirection", myDirection)
    env.put("LOG_myForce", myForce)

    let destination = self.getCoordinates() + sumOfForces + myForce
    env.put("state", "following")
    env.put("destination", destination)
    env.put("heading", destination)
}