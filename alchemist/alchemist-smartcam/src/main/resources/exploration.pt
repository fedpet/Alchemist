module exploration
import utils
import java.lang.Math.abs


def getEnvironmentBoundaryForce(envPoint) {
    let myPos = self.getCoordinates()
    let versor = unitVector(myPos - envPoint)
    10000 / distanceBetweenPos(myPos, envPoint) ^ 2 * versor
}

def getEnvironmentBoundariesForce() {
    let halfEnvSize = env.get("EnvironmentSize") / 2
    let myCoords = self.getCoordinates()
    let myX = myCoords.get(0)
    let myY = myCoords.get(1)
    let top = getEnvironmentBoundaryForce([myX, halfEnvSize])
    let right = getEnvironmentBoundaryForce([halfEnvSize, myY])
    let bottom = getEnvironmentBoundaryForce([myX, -halfEnvSize])
    let left = getEnvironmentBoundaryForce([-halfEnvSize, myY])
    top + right + bottom + left
}

def chooseNextDirection() {
    [2 * self.nextRandomDouble() - 1, 2 * self.nextRandomDouble() - 1]
}

/*
def messageFromTo(from, to, content) {
    let local = broadcast(from, [to, content])
    if (local.get(0) == io) { local[1] } else { none() }
}
*/

def chooseDirection() {
    let HYSTERESIS = 10
    rep(info <- [self.getCoordinates(), chooseNextDirection(), HYSTERESIS]) {
        let lastPos = info.get(0)
        let myDirection = info.get(1)
        let hyst = info.get(2)

        let myPos = self.getCoordinates()
        let realDirectionOfMovement = lastPos - myPos
        let realDirectionAngle = directionToAngle(realDirectionOfMovement)
        let myDirectionAngle = directionToAngle(myDirection)
        myDirection = if((distanceBetweenPos(myPos, lastPos) < getMaxMovementSpeed() / 2
            && abs(realDirectionAngle - myDirectionAngle) > 1.14)
            || distanceBetweenPos(myPos, lastPos) < getMaxMovementSpeed() / 4) {
            if(hyst < 0) {
                hyst = HYSTERESIS
                chooseNextDirection()
            } else {
                hyst = hyst - 1
                myDirection
            }
        } else {
            myDirection
        }
        [myPos, myDirection, hyst]
    } yield {
        info.get(1)
    }
}

public def fieldExploration() {
    let cameraVersorsField = nbrVersor()
    //env.putField("LOG_vector", cameraVersorsField)

    let distanceFromCamerasField = self.nbrRange()
    env.putField("LOG_distanceFromCamerasField", distanceFromCamerasField)

    let cameraForces = 10000 / distanceFromCamerasField ^ 2 * cameraVersorsField
    env.putField("LOG_cameraForces", cameraForces)

    let envBoundariesForce = getEnvironmentBoundariesForce()
    env.put("LOG_envBoundariesForce", envBoundariesForce)

    env.put("LOG_cameraSumForces", sumHood(cameraForces))
    let sumOfForces = sumHood(cameraForces) + envBoundariesForce
    env.put("LOG_sumOfForces", sumOfForces)

    let myForceOfWill = 10
    let myDirection = chooseDirection()
    let myForce = myDirection * myForceOfWill
    env.put("LOG_myDirection", myDirection)
    env.put("LOG_myForce", myForce)

    let destination = self.getCoordinates() + sumOfForces + myForce
    env.put("state", "following")
    env.put("destination", destination)
    env.put("heading", destination)
}